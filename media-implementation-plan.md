# План реализации системы управления мультимедиа

## Обзор

План из 15 задач для реализации полнофункциональной системы управления мультимедиа в CMS Panel, учитывающий принципы UX из `ux.md` и технические требования проекта.

---

## Задача 1: Создание Zod-схем для типов медиа

**Цель:** Определить типизированные схемы валидации для всех типов медиа-файлов.

**Детали:**
- Создать файл `src/types/media.ts`
- Реализовать базовую схему `zMediaBase` с общими полями (id, kind, name, ext, mime, size_bytes, title, alt, collection, created_at, updated_at, deleted_at, url)
- Создать специализированные схемы:
  - `zMediaImage` (kind: 'image') с полями: width, height, preview_urls (thumbnail, medium, large)
  - `zMediaVideo` (kind: 'video') с полями: duration_ms, bitrate_kbps, frame_rate, frame_count, video_codec, audio_codec
  - `zMediaAudio` (kind: 'audio') с полями: duration_ms, bitrate_kbps, audio_codec
  - `zMediaDocument` (kind: 'document') без дополнительных полей
- Объединить через discriminated union по полю `kind`: `zMedia = z.discriminatedUnion('kind', [zMediaImage, zMediaVideo, zMediaAudio, zMediaDocument])`
- Создать схемы для ответов API: `zMediaResponse`, `zMediaListResponse`, `zMediaConfigResponse`
- Создать схемы для параметров запросов: `zMediaListParams`, `zMediaUploadPayload`, `zMediaUpdatePayload`
- Создать схему для конфигурации медиа: `zMediaConfig` (разрешенные MIME-типы, максимальный размер, варианты изображений)

**Принципы UX:** Прозрачная модель данных (п.2), учет специфики мультимедиа (п.9)

---

## Задача 2: Реализация API-функций для работы с медиа

**Цель:** Создать набор функций для взаимодействия с backend API медиа.

**Детали:**
- Создать файл `src/api/apiMedia.ts`
- Реализовать функции:
  - `getMediaConfig()` — получение конфигурации медиа-системы
  - `listMedia(params: ZMediaListParams)` — список медиа с фильтрами и пагинацией
  - `getMedia(id: string)` — получение конкретного медиа-файла
  - `uploadMedia(file: File, payload: ZMediaUploadPayload)` — загрузка нового файла (multipart/form-data)
  - `updateMedia(id: string, payload: ZMediaUpdatePayload)` — обновление метаданных
  - `deleteMedia(id: string)` — мягкое удаление
  - `restoreMedia(id: string)` — восстановление удаленного
  - `bulkDeleteMedia(ids: string[])` — массовое удаление
  - `bulkRestoreMedia(ids: string[])` — массовое восстановление
  - `bulkForceDeleteMedia(ids: string[])` — окончательное удаление
- Использовать паттерн из `apiEntries.ts`: валидация через Zod, обработка ошибок через `onError`
- Для загрузки файлов использовать `FormData` и `multipart/form-data`

**Принципы UX:** Мощный поиск и фильтры (п.3), оптимизация под большие объемы (п.4)

---

## Задача 3: Создание MediaListStore для управления списком медиа

**Цель:** Реализовать MobX store для управления состоянием списка медиа с фильтрацией, поиском и пагинацией.

**Детали:**
- Создать файл `src/pages/MediaListPage/MediaListStore.ts`
- Использовать паттерн из `EntriesListStore.ts` с `PaginatedDataLoader`
- Реализовать методы:
  - `loadMedia()` — загрузка списка
  - `setFilters(filters: Partial<ZMediaListParams>)` — установка фильтров (kind, mime, collection, deleted, q, sort, order)
  - `goToPage(page: number)` — переход на страницу
  - `resetFilters()` — сброс фильтров
  - `initialize()` — инициализация при открытии страницы
- Добавить состояние для выбранных медиа-файлов: `selectedIds: Set<string>`
- Добавить методы массовых операций: `selectAll()`, `deselectAll()`, `toggleSelection(id: string)`
- Добавить загрузку конфигурации: `loadConfig()`, `config: ZMediaConfig | null`

**Принципы UX:** Мощный поиск и фильтры (п.3), оптимизация под большие объемы (п.4), прозрачные состояния (п.7)

---

## Задача 4: Создание MediaEditorStore для редактирования медиа

**Цель:** Реализовать store для управления состоянием редактирования отдельного медиа-файла.

**Детали:**
- Создать файл `src/pages/MediaEditorPage/MediaEditorStore.ts`
- Реализовать состояние:
  - `media: ZMedia | null` — текущий медиа-файл
  - `pending: boolean` — флаг загрузки
  - `saving: boolean` — флаг сохранения
  - `formData: Partial<ZMediaUpdatePayload>` — данные формы
- Реализовать методы:
  - `loadMedia(id: string)` — загрузка медиа
  - `updateFormField(field: keyof ZMediaUpdatePayload, value: unknown)` — обновление поля формы
  - `save()` — сохранение изменений
  - `delete()` — удаление медиа
  - `restore()` — восстановление
- Добавить валидацию формы перед сохранением

**Принципы UX:** Контекстное управление (п.5), прозрачные состояния (п.7)

---

## Задача 5: Создание компонента MediaCard для отображения медиа-карточки

**Цель:** Реализовать компонент карточки медиа-файла с превью и базовыми действиями.

**Детали:**
- Создать файл `src/components/MediaCard/MediaCard.tsx`
- Реализовать отображение:
  - Превью в зависимости от типа (изображение — `<img>`, видео — thumbnail с иконкой, аудио — иконка, документ — иконка)
  - Название файла (title или name)
  - Бейдж типа медиа (kind)
  - Размер файла (форматированный)
  - Дата создания/обновления
  - Индикатор удаления (если deleted_at не null)
- Реализовать действия:
  - Клик по карточке — открытие редактора
  - Контекстное меню (правый клик) — редактирование, удаление, копирование ссылки
  - Чекбокс для выбора (если передан `selectable`)
- Использовать Ant Design компоненты: `Card`, `Image`, `Tag`, `Tooltip`
- Добавить поддержку вариантов изображений через `preview_urls` (thumbnail для списка)

**Принципы UX:** Контекстное управление (п.5), визуальная иерархия (п.6), учет специфики мультимедиа (п.9)

---

## Задача 6: Создание компонента MediaGrid для отображения сетки медиа

**Цель:** Реализовать компонент сетки медиа-файлов с виртуальной прокруткой для больших объемов.

**Детали:**
- Создать файл `src/components/MediaGrid/MediaGrid.tsx`
- Использовать Ant Design `Row` и `Col` или `List` с `grid` prop для сетки
- Реализовать виртуальную прокрутку через `react-window` или встроенные возможности Ant Design
- Поддержать режимы отображения:
  - Плитка (grid) — основной режим для визуального отбора
  - Список (list) — компактный режим для массовых операций
- Реализовать выбор множественных элементов через чекбоксы
- Добавить индикатор загрузки при подгрузке данных
- Использовать `MediaCard` для отображения каждого элемента

**Принципы UX:** Оптимизация под большие объемы (п.4), визуальная иерархия (п.6)

---

## Задача 7: Создание компонента MediaFilters для фильтрации медиа

**Цель:** Реализовать панель фильтров для поиска и фильтрации медиа-файлов.

**Детали:**
- Создать файл `src/components/MediaFilters/MediaFilters.tsx`
- Использовать паттерн из `FilterForm.tsx`
- Реализовать фильтры:
  - Поиск по названию/имени (`q`)
  - Тип медиа (`kind`: image, video, audio, document)
  - MIME-тип (`mime` — префиксный поиск)
  - Коллекция (`collection`)
  - Статус удаления (`deleted`: with, only)
  - Сортировка (`sort`: created_at, size_bytes, mime)
  - Направление сортировки (`order`: asc, desc)
- Использовать Ant Design компоненты: `Input`, `Select`, `DatePicker`, `Button`
- Добавить кнопку "Сбросить фильтры"
- Сохранять состояние фильтров в URL (query params) для deep-links

**Принципы UX:** Мощный поиск и фильтры (п.3), прозрачная модель контента (п.2)

---

## Задача 8: Создание компонента MediaUpload для загрузки файлов

**Цель:** Реализовать компонент загрузки медиа-файлов с drag-and-drop и прогресс-баром.

**Детали:**
- Создать файл `src/components/MediaUpload/MediaUpload.tsx`
- Использовать Ant Design `Upload` компонент с настройками:
  - Поддержка drag-and-drop
  - Множественная загрузка
  - Валидация типов файлов из конфигурации
  - Валидация размера файлов
- Реализовать отображение прогресса загрузки для каждого файла
- Добавить предпросмотр загружаемых файлов (для изображений)
- Реализовать обработку ошибок с понятными сообщениями
- Добавить возможность указать коллекцию и метаданные (title, alt) перед загрузкой
- Использовать `uploadMedia` из `apiMedia.ts`

**Принципы UX:** Фокус на реальных задачах (п.1), богатый фидбек (п.7), учет специфики мультимедиа (п.9)

---

## Задача 9: Создание страницы MediaListPage для списка медиа

**Цель:** Реализовать главную страницу управления медиа с фильтрами, сеткой и массовыми операциями.

**Детали:**
- Создать файл `src/pages/MediaListPage/MediaListPage.tsx`
- Использовать паттерн из `EntriesListPage.tsx`
- Структура страницы:
  - Заголовок с кнопкой "Загрузить медиа"
  - Панель фильтров (`MediaFilters`)
  - Панель массовых действий (показывается при выборе элементов):
    - Удалить выбранные
    - Восстановить выбранные (если есть удаленные)
    - Переместить в коллекцию
  - Сетка медиа (`MediaGrid`)
  - Пагинация (`Pagination` из Ant Design)
- Использовать `MediaListStore` для управления состоянием
- Добавить обработку пустого состояния с подсказкой "Загрузите первые файлы"
- Реализовать роутинг через `routes.tsx`

**Принципы UX:** Фокус на реальных задачах (п.1), оптимизация под большие объемы (п.4), ясная онбординг-стратегия (п.14)

---

## Задача 10: Создание страницы MediaEditorPage для редактирования медиа

**Цель:** Реализовать страницу детального просмотра и редактирования медиа-файла.

**Детали:**
- Создать файл `src/pages/MediaEditorPage/MediaEditorPage.tsx`
- Структура страницы:
  - Заголовок с кнопками: "Сохранить", "Удалить", "Восстановить" (если удалено)
  - Основная область:
    - Превью медиа (полноразмерное для изображений, плеер для видео/аудио)
    - Форма редактирования метаданных:
      - Название (title)
      - Альтернативный текст (alt)
      - Коллекция (collection)
      - Дополнительные поля в зависимости от типа (для изображений — размер, для видео — длительность и т.д.)
  - Боковая панель с информацией:
    - Технические данные (размер, MIME, даты)
    - Ссылка на файл
    - Варианты изображений (если kind === 'image')
- Использовать `MediaEditorStore` для управления состоянием
- Реализовать инлайн-редактирование полей (без модальных окон)
- Добавить валидацию формы перед сохранением

**Принципы UX:** Контекстное управление (п.5), прозрачная модель контента (п.2), учет специфики мультимедиа (п.9)

---

## Задача 11: Создание компонента MediaPreview для предпросмотра медиа

**Цель:** Реализовать компонент предпросмотра медиа с поддержкой всех типов файлов.

**Детали:**
- Создать файл `src/components/MediaPreview/MediaPreview.tsx`
- Реализовать отображение в зависимости от типа:
  - Изображения: `<Image>` с поддержкой вариантов (thumbnail, medium, large, original)
  - Видео: HTML5 `<video>` с controls
  - Аудио: HTML5 `<audio>` с controls
  - Документы: иконка + ссылка на скачивание
- Добавить поддержку полноэкранного режима для изображений и видео
- Реализовать навигацию между медиа в списке (стрелки влево/вправо)
- Добавить информацию о файле (размер, формат, дата)
- Использовать Ant Design `Image` для изображений с preview-группой

**Принципы UX:** Контекстное управление (п.5), учет специфики мультимедиа (п.9), визуальная иерархия (п.6)

---

## Задача 12: Создание страницы MediaTrashPage для удаленных медиа

**Цель:** Реализовать страницу управления удаленными медиа-файлами с возможностью восстановления или окончательного удаления.

**Детали:**
- Создать файл `src/pages/MediaTrashPage/MediaTrashPage.tsx`
- Использовать `MediaListStore` с фильтром `deleted: 'only'`
- Структура страницы:
  - Заголовок "Корзина"
  - Информация о количестве удаленных файлов
  - Сетка медиа (`MediaGrid`) с удаленными файлами
  - Панель массовых действий:
    - Восстановить выбранные
    - Окончательно удалить выбранные (с подтверждением)
    - Очистить корзину (удалить все)
- Добавить предупреждения при окончательном удалении
- Использовать визуальные индикаторы удаления (полупрозрачность, бейдж "Удалено")

**Принципы UX:** Ошибкоустойчивость (п.8), прозрачные операции (п.15), богатый фидбек (п.7)

---

## Задача 13: Интеграция медиа в навигацию и роутинг

**Цель:** Добавить страницы медиа в навигацию приложения и настроить роутинг.

**Детали:**
- Обновить `src/layouts/layoutNavigation.ts`:
  - Добавить пункт меню "Медиа" с подпунктами:
    - "Все медиа" → `/media`
    - "Корзина" → `/media/trash`
- Обновить `src/routes.tsx`:
  - Добавить маршруты:
    - `/media` → `MediaListPage`
    - `/media/:id` → `MediaEditorPage`
    - `/media/trash` → `MediaTrashPage`
- Обновить `src/PageUrl.ts` для типизации URL медиа
- Добавить breadcrumbs на страницах медиа

**Принципы UX:** Прозрачная модель контента (п.2), последовательная дизайн-система (п.11)

---

## Задача 14: Реализация массовых операций с медиа

**Цель:** Добавить функциональность массовых операций над выбранными медиа-файлами.

**Детали:**
- Расширить `MediaListStore`:
  - Добавить методы:
    - `bulkDelete(ids: string[])` — массовое удаление
    - `bulkRestore(ids: string[])` — массовое восстановление
    - `bulkForceDelete(ids: string[])` — окончательное удаление
    - `bulkUpdateCollection(ids: string[], collection: string)` — изменение коллекции
- Создать компонент `MediaBulkActions.tsx`:
  - Показывается только при выборе элементов
  - Кнопки действий с подтверждением для деструктивных операций
  - Отображение количества выбранных элементов
- Добавить обработку ошибок при массовых операциях
- Добавить уведомления об успешном выполнении операций

**Принципы UX:** Оптимизация под большие объемы (п.4), прозрачные операции (п.15), богатый фидбек (п.7)

---

## Задача 15: Оптимизация производительности и финальная полировка

**Цель:** Оптимизировать производительность, добавить финальные улучшения UX и обеспечить доступность.

**Детали:**
- Оптимизация:
  - Ленивая загрузка изображений (lazy loading)
  - Виртуальная прокрутка для больших списков
  - Мемоизация компонентов через `React.memo` где необходимо
  - Дебаунсинг поиска и фильтров
- Доступность:
  - Добавить ARIA-атрибуты для всех интерактивных элементов
  - Обеспечить клавиатурную навигацию
  - Добавить альтернативные тексты для всех изображений
  - Проверить контрастность цветов
- UX улучшения:
  - Добавить пустые состояния с подсказками
  - Реализовать сохранение пользовательских предпочтений (вид отображения, сортировка)
  - Добавить быстрые действия через горячие клавиши
  - Реализовать копирование ссылки на медиа в буфер обмена
- Тестирование:
  - Проверить работу на разных типах медиа
  - Проверить обработку ошибок
  - Проверить производительность с большим количеством файлов

**Принципы UX:** Все принципы, особенно доступность (п.12), производительность (п.4), последовательная дизайн-система (п.11)

---

## Порядок выполнения

Рекомендуемый порядок выполнения задач для минимизации блокировок:

1. **Задачи 1-2** (Типы и API) — основа для всех остальных задач
2. **Задача 3** (MediaListStore) — основа для списка медиа
3. **Задачи 5-7** (Компоненты: MediaCard, MediaGrid, MediaFilters) — UI компоненты
4. **Задача 9** (MediaListPage) — основная страница списка
5. **Задача 4** (MediaEditorStore) — основа для редактора
6. **Задачи 10-11** (MediaEditorPage, MediaPreview) — страница редактора
7. **Задача 8** (MediaUpload) — загрузка файлов
8. **Задача 12** (MediaTrashPage) — корзина
9. **Задача 13** (Интеграция в навигацию) — связывание всего вместе
10. **Задача 14** (Массовые операции) — расширенная функциональность
11. **Задача 15** (Оптимизация) — финальная полировка

---

## Технические требования

- **Zod схемы:** Отдельные схемы для каждого типа медиа, объединенные через discriminated union по полю `kind`
- **Логика в сторах:** Вся бизнес-логика в MobX stores, компоненты только рендерят
- **Без кастомных хуков:** Использовать только стандартные React хуки, логику выносить в утилиты или методы стора
- **Минималистичный код:** Прямолинейный, простой для чтения код без избыточных абстракций
- **JSDoc документация:** Все публичные API должны быть задокументированы согласно правилам проекта

