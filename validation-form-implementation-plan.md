# План реализации форм настройки валидации для Path

Документ описывает план реализации системы настройки правил валидации для полей Path в Blueprint.

## Контекст

Согласно документации `blueprint-validation-frontend.md`, правила валидации (`validation_rules`) должны быть объектом JSON со следующими возможными полями:

- `min`, `max` - минимальное/максимальное значение или длина
- `pattern` - регулярное выражение
- `array_min_items`, `array_max_items`, `array_unique` - правила для массивов
- `required_if`, `prohibited_unless`, `required_unless`, `prohibited_if` - условные правила
- `unique` - правило уникальности
- `exists` - правило существования
- `field_comparison` - сравнение полей

Текущая система использует старый формат `validation_rules` как массив правил. Необходимо обновить систему для поддержки нового формата из документации.

## Задачи

### Задача 1: Обновить типы для validation_rules

**Цель:** Привести типы TypeScript в соответствие с форматом из документации.

**Действия:**

1. Создать новый тип `ZValidationRules` в `src/types/path.ts` на основе структуры из документации
2. Обновить схемы Zod для `validation_rules` в `zPathBase`, `zCreatePathDto`, `zUpdatePathDto`
3. Заменить `z.array(zValidationRule).nullable()` на новый тип `zValidationRules.nullable()`
4. Сохранить обратную совместимость со старым форматом (если требуется)

**Файлы:**

- `src/types/path.ts`

**Критерии готовности:**

- Типы соответствуют структуре из документации
- Zod схемы валидируют новый формат
- TypeScript компилируется без ошибок

---

### Задача 2: Создать компонент ValidationRulesForm

**Цель:** Создать форму для настройки правил валидации.

**Действия:**

1. Создать файл `src/components/paths/ValidationRulesForm.tsx`
2. Реализовать форму с полями для всех типов правил валидации:
   - Базовые правила: `min`, `max`, `pattern`
   - Правила для массивов: `array_min_items`, `array_max_items`, `array_unique` (только для `cardinality: 'many'`)
   - Условные правила: `required_if`, `prohibited_unless`, `required_unless`, `prohibited_if`
   - Правила уникальности: `unique`
   - Правила существования: `exists`
   - Сравнение полей: `field_comparison`
3. Использовать Ant Design компоненты (InputNumber, Input, Select, Switch, Collapse для группировки)
4. Добавить условную логику отображения полей в зависимости от `data_type` и `cardinality`
5. Добавить валидацию формы через Ant Design Form

**Файлы:**

- `src/components/paths/ValidationRulesForm.tsx`

**Пропсы:**

```typescript
type PropsValidationRulesForm = {
  form: FormInstance;
  dataType?: ZDataType;
  cardinality?: ZCardinality;
  isReadonly?: boolean;
};
```

**Критерии готовности:**

- Форма отображает все типы правил валидации
- Поля условно показываются/скрываются в зависимости от типа данных и кардинальности
- Форма интегрируется с Ant Design Form

---

### Задача 3: Добавить табы в NodeFormModal

**Цель:** Разделить форму на две вкладки: "Основное" и "Валидация".

**Действия:**

1. Импортировать компонент `Tabs` из `antd`
2. Обернуть содержимое модального окна в `Tabs`
3. Создать две вкладки:
   - "Основное" - содержит существующий `NodeForm`
   - "Валидация" - содержит новый `ValidationRulesForm`
4. Условно показывать вкладку "Валидация" только для режимов `create` и `edit` (не для `embed`)
5. Скрывать вкладку "Валидация" для полей типа `json` (валидация настраивается для дочерних полей)

**Файлы:**

- `src/components/paths/NodeFormModal.tsx`

**Критерии готовности:**

- Модальное окно содержит две вкладки
- Вкладка "Валидация" показывается только когда нужно
- Переключение между вкладками работает корректно

---

### Задача 4: Интегрировать ValidationRulesForm в NodeFormModal

**Цель:** Подключить форму валидации к общей форме модального окна.

**Действия:**

1. Импортировать `ValidationRulesForm` в `NodeFormModal`
2. Передать `form`, `dataType`, `cardinality`, `isReadonly` в `ValidationRulesForm`
3. Получать `dataType` и `cardinality` из формы через `Form.useWatch`
4. Обеспечить синхронизацию данных между вкладками через общий `form` instance
5. При инициализации формы загружать существующие `validation_rules` из `initialValues`

**Файлы:**

- `src/components/paths/NodeFormModal.tsx`

**Критерии готовности:**

- Форма валидации получает корректные данные из основной формы
- При открытии модального окна в режиме редактирования загружаются существующие правила
- Данные сохраняются в общий объект формы

---

### Задача 5: Реализовать преобразование данных validation_rules

**Цель:** Создать утилиты для преобразования validation_rules между форматом формы и форматом API.

**Действия:**

1. Создать файл `src/utils/validationRules.ts`
2. Реализовать функцию `normalizeValidationRulesForForm` - преобразует данные из API в формат формы
3. Реализовать функцию `normalizeValidationRulesForApi` - преобразует данные из формы в формат API
4. Обработать случаи с `null`, пустыми объектами, условными правилами
5. Добавить JSDoc комментарии с примерами использования

**Файлы:**

- `src/utils/validationRules.ts`

**Критерии готовности:**

- Утилиты корректно преобразуют данные в обе стороны
- Обрабатываются все типы правил валидации
- Утилиты покрыты JSDoc документацией

---

### Задача 6: Обновить логику сохранения в NodeFormModal

**Цель:** Обеспечить отправку validation_rules при сохранении формы.

**Действия:**

1. В функции `handleOk` получить значения из всех полей формы, включая `validation_rules`
2. Преобразовать `validation_rules` через `normalizeValidationRulesForApi`
3. Включить `validation_rules` в объект для отправки на бэкенд
4. Обработать случай, когда `validation_rules` пустой объект (отправить `null` или `{}` в зависимости от требований API)
5. Обновить валидацию через Zod схемы

**Файлы:**

- `src/components/paths/NodeFormModal.tsx`

**Критерии готовности:**

- При сохранении отправляются корректные `validation_rules`
- Пустые правила обрабатываются правильно
- Валидация работает корректно

---

### Задача 7: Реализовать UI для условных правил

**Цель:** Создать удобный интерфейс для настройки условных правил (required_if, prohibited_unless и т.д.).

**Действия:**

1. В `ValidationRulesForm` добавить секцию для условных правил
2. Реализовать форму для настройки:
   - Поле `field` (выбор из доступных полей Blueprint или ввод пути)
   - Поле `value` (опциональное, зависит от типа поля)
   - Поле `operator` (Select с опциями: `==`, `!=`, `>`, `<`, `>=`, `<=`)
3. Поддержать простой формат (строка) и расширенный формат (объект)
4. Добавить валидацию и подсказки

**Файлы:**

- `src/components/paths/ValidationRulesForm.tsx`

**Критерии готовности:**

- Пользователь может настроить все типы условных правил
- Интерфейс интуитивно понятен
- Валидация работает корректно

---

### Задача 8: Реализовать UI для правил unique и exists

**Цель:** Создать интерфейс для настройки правил уникальности и существования.

**Действия:**

1. В `ValidationRulesForm` добавить секции для `unique` и `exists`
2. Для `unique`:
   - Поле `table` (обязательное)
   - Поле `column` (опциональное)
   - Секция `except` с полями `column` и `value`
   - Секция `where` с полями `column` и `value`
3. Для `exists`:
   - Поле `table` (обязательное)
   - Поле `column` (опциональное)
   - Секция `where` с полями `column` и `value`
4. Поддержать простой формат (строка для `table`) и расширенный формат (объект)
5. Добавить валидацию и подсказки

**Файлы:**

- `src/components/paths/ValidationRulesForm.tsx`

**Критерии готовности:**

- Пользователь может настроить правила unique и exists
- Поддерживаются простой и расширенный форматы
- Валидация работает корректно

---

### Задача 9: Реализовать UI для field_comparison

**Цель:** Создать интерфейс для настройки сравнения полей.

**Действия:**

1. В `ValidationRulesForm` добавить секцию для `field_comparison`
2. Реализовать форму с полями:
   - `operator` (Select: `>=`, `<=`, `>`, `<`, `==`, `!=`)
   - `field` (опциональное, путь к другому полю)
   - `value` (опциональное, константное значение)
3. Добавить валидацию: должно быть указано либо `field`, либо `value`
4. Добавить подсказки и примеры использования

**Файлы:**

- `src/components/paths/ValidationRulesForm.tsx`

**Критерии готовности:**

- Пользователь может настроить сравнение полей
- Валидация проверяет наличие field или value
- Интерфейс понятен

---

### Задача 10: Добавить обработку ошибок и тестирование

**Цель:** Обеспечить корректную обработку ошибок и протестировать функциональность.

**Действия:**

1. Добавить обработку ошибок валидации от бэкенда
2. Отображать ошибки валидации в соответствующих полях формы
3. Добавить обработку ошибок сети и других ошибок API
4. Протестировать создание поля с правилами валидации
5. Протестировать обновление правил валидации
6. Протестировать различные комбинации правил
7. Протестировать условное отображение полей в зависимости от `data_type` и `cardinality`

**Файлы:**

- `src/components/paths/NodeFormModal.tsx`
- `src/components/paths/ValidationRulesForm.tsx`
- `src/utils/validationRules.ts`

**Критерии готовности:**

- Ошибки валидации отображаются корректно
- Ошибки сети обрабатываются
- Все сценарии протестированы и работают
- Код готов к использованию

---

## Дополнительные замечания

1. **Обратная совместимость:** Если бэкенд еще поддерживает старый формат `validation_rules` (массив), необходимо обеспечить преобразование между форматами.

2. **Валидация на фронтенде:** Рекомендуется добавить базовую валидацию на фронтенде для улучшения UX, но всегда полагаться на валидацию бэкенда.

3. **Типизация:** Все функции и компоненты должны быть полностью типизированы с использованием TypeScript и Zod схем.

4. **Документация:** Все новые функции и компоненты должны иметь JSDoc комментарии согласно правилам проекта.

5. **Стилизация:** Использовать Tailwind CSS для стилизации, Ant Design компоненты для UI элементов.

6. **Производительность:** Избегать ненужных ре-рендеров, использовать `useMemo` и `useCallback` где необходимо.

---

## Порядок выполнения

Рекомендуемый порядок выполнения задач:

1. Задача 1 (типы) - основа для всех остальных задач
2. Задача 5 (утилиты) - нужны для задач 4 и 6
3. Задача 2 (ValidationRulesForm) - основной компонент
4. Задачи 7-9 (UI для различных правил) - детализация компонента
5. Задача 3 (табы) - структура модального окна
6. Задача 4 (интеграция) - подключение компонентов
7. Задача 6 (сохранение) - логика отправки данных
8. Задача 10 (тестирование) - финальная проверка

---

## Критерии успеха

Реализация считается успешной, если:

- ✅ Пользователь может настроить все типы правил валидации через UI
- ✅ Правила валидации корректно сохраняются на бэкенд
- ✅ При редактировании существующего поля правила загружаются и отображаются корректно
- ✅ Форма валидируется на фронтенде и бэкенде
- ✅ Ошибки обрабатываются и отображаются пользователю
- ✅ Код соответствует правилам проекта (минималистичный, типизированный, документированный)
