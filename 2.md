# Универсальная схема‑ориентированная форма (MobX + Ant Design)

Этот документ описывает «синтезированный» подход к построению форм на основе схемы для управления сущностями вроде товара (`title`, `sku`, `price`, `in_stock`, `description`, вложенный `rrrr.eeee`).

Подход объединяет сильные стороны двух вариантов архитектуры:

- мощную типизацию и рекурсивный рендеринг,
- прозрачную структуру, простую эволюцию и разделение слоёв (schema → модель → UI).

---

## 1. Цели архитектуры

1. **Единый источник правды** — схема описывает структуру данных, правила валидации и часть UI‑мета.
2. **Сильная типизация** — тип значений формы автоматически выводится из схемы.
3. **MobX как core‑состояние** — UI‑библиотека (AntD и др.) становится слоем представления, который легко заменить.
4. **Расширяемость** — новое поле/тип/виджет добавляется через схему и реестры, а не переписывание кода.
5. **Поддержка вложенных структур и массивов** — рекурсивный рендеринг, `cardinality: "one" | "many"`, `type: "json"` с `children`.

---

## 2. Формат схемы

Базовая модель поля:

```ts
export type FieldType = 'string' | 'float' | 'bool' | 'text' | 'json';
export type Cardinality = 'one' | 'many';

export interface ValidationSpec {
  type: 'required' | 'min' | 'max' | 'regex' | 'enum' | 'custom';
  value?: any;
  message?: string;
  validatorKey?: string; // имя кастомного валидатора в реестре
}

export interface FieldSchema {
  type: FieldType;
  required: boolean;
  indexed: boolean;
  cardinality: Cardinality;
  validation: ValidationSpec[];
  children?: Record<string, FieldSchema>;

  // UI‑метаданные (необязательные, но полезные):
  label?: string;
  placeholder?: string;
  uiWidget?: string; // ключ виджета в реестре
  uiProps?: Record<string, any>;
  group?: string; // логическая группа / секция
}

export interface EntitySchema {
  schema: Record<string, FieldSchema>;
}
```

Пример схемы товара:

```ts
export const productSchema: EntitySchema = {
  schema: {
    rrrr: {
      type: 'json',
      required: false,
      indexed: false,
      cardinality: 'many',
      validation: [],
      label: 'RRRR',
      children: {
        eeee: {
          type: 'string',
          required: false,
          indexed: false,
          cardinality: 'many',
          validation: [],
          label: 'EEEE',
        },
      },
    },
    title: {
      type: 'string',
      required: true,
      indexed: true,
      cardinality: 'one',
      validation: [],
      label: 'Название',
      uiWidget: 'title',
    },
    sku: {
      type: 'string',
      required: true,
      indexed: true,
      cardinality: 'one',
      validation: [],
      label: 'SKU',
    },
    price: {
      type: 'float',
      required: true,
      indexed: true,
      cardinality: 'one',
      validation: [{ type: 'min', value: 0, message: 'Цена не может быть отрицательной' }],
      label: 'Цена',
      uiWidget: 'price',
    },
    in_stock: {
      type: 'bool',
      required: false,
      indexed: true,
      cardinality: 'one',
      validation: [],
      label: 'В наличии',
    },
    description: {
      type: 'text',
      required: false,
      indexed: false,
      cardinality: 'one',
      validation: [],
      label: 'Описание',
    },
  },
};
```

---

## 3. Типизация значений формы (`InferFormValues`)

Цель — чтобы TypeScript автоматически выводил тип `FormValues` из `EntitySchema`, включая вложенные `json` и `many`‑поля.

```ts
type InferFieldValue<F extends FieldSchema> = F['type'] extends 'json'
  ? F['children'] extends Record<string, FieldSchema>
    ? InferFormValues<F['children']>
    : unknown
  : F['type'] extends 'string' | 'text'
    ? string
    : F['type'] extends 'float'
      ? number
      : F['type'] extends 'bool'
        ? boolean
        : unknown;

export type InferFormValues<S extends Record<string, FieldSchema>> = {
  [K in keyof S]: S[K]['cardinality'] extends 'many'
    ? Array<InferFieldValue<S[K]>>
    : InferFieldValue<S[K]>;
};

export type FormValues<E extends EntitySchema> = InferFormValues<E['schema']>;
```

Для `productSchema` тип будет:

```ts
type ProductFormValues = FormValues<typeof productSchema>;

// Результат:
type ProductFormValues = {
  rrrr: { eeee: string[] }[];
  title: string;
  sku: string;
  price: number;
  in_stock: boolean;
  description: string;
};
```

Никакого ручного описания типов не нужно — структура полностью следует из схемы.

---

## 4. FormModel на MobX

FormModel — единый источник истины для состояния формы: значения, ошибки, валидация, операции над массивами и т.п.

```ts
type PathSegment = string | number;

const getValueByPath = (obj: any, path: PathSegment[]): any => {
  return path.reduce((acc, seg) => (acc == null ? acc : acc[seg]), obj);
};

const setValueByPath = (obj: any, path: PathSegment[], value: any) => {
  if (!path.length) return;
  const last = path[path.length - 1];
  const parent = path.slice(0, -1).reduce((acc, seg) => {
    if (acc[seg] == null) acc[seg] = typeof seg === 'number' ? [] : {};
    return acc[seg];
  }, obj);
  parent[last] = value;
};

const pathToString = (path: PathSegment[]): string =>
  path
    .map((seg, idx) => (typeof seg === 'number' ? `[${seg}]` : idx === 0 ? seg : `.${seg}`))
    .join('')
    .replace('.[', '[');
```

```ts
class FormModel<E extends EntitySchema> {
  schema: E;
  values: FormValues<E>;
  errors: Map<string, string[]>;

  constructor(schema: E, initial?: Partial<FormValues<E>>) {
    makeAutoObservable(this, {}, { autoBind: true });
    this.schema = schema;
    this.values = this.createDefaultValues(schema, initial);
    this.errors = new Map();
  }

  private createDefaultValues(schema: E, initial?: Partial<FormValues<E>>): FormValues<E> {
    // Логика инициализации значений из схемы + initial
    // (для примитивов можно брать null/''/0/false, для many — []).
    return {
      ...(initial as any),
    };
  }

  setValue(path: PathSegment[], value: any) {
    setValueByPath(this.values, path, value);
  }

  setAll(values: Partial<FormValues<E>>) {
    this.values = { ...this.values, ...values } as FormValues<E>;
  }

  addArrayItem(path: PathSegment[], item: unknown) {
    const arr = getValueByPath(this.values, path) as unknown[];
    if (Array.isArray(arr)) {
      arr.push(item);
    } else {
      setValueByPath(this.values, path, [item]);
    }
  }

  removeArrayItem(path: PathSegment[], index: number) {
    const arr = getValueByPath(this.values, path) as unknown[];
    if (Array.isArray(arr)) {
      arr.splice(index, 1);
    }
  }

  validate(): boolean {
    this.errors.clear();
    // Рекурсивный обход схемы и значений,
    // применение ValidationSpec и запись ошибок в this.errors
    // по ключам вида "rrrr[0].eeee[1]".
    return this.errors.size === 0;
  }

  get isValid() {
    return this.errors.size === 0;
  }

  errorFor(path: string): string | undefined {
    const list = this.errors.get(path);
    return list?.[0];
  }

  get json(): FormValues<E> {
    return this.values;
  }
}
```

**Принцип:** AntD‑форма читает и записывает значения через `FormModel`, а не наоборот. MobX‑модель — ядро, UI — оболочка.

---

## 5. Валидация: единый DSL + мост в AntD

### 5.1. Единый DSL (`ValidationSpec`)

- Все правила описаны в `validation` и флагах `required` на уровне схемы.
- FormModel использует эти же правила в методе `validate()`.
- Для AntD генерируются `rules` из тех же `ValidationSpec` — не дублируются «ручные» правила.

### 5.2. Генерация AntD‑правил

```ts
import type { Rule } from 'antd/es/form';

const buildAntdRules = (field: FieldSchema): Rule[] => {
  const rules: Rule[] = [];

  if (field.required) {
    rules.push({ required: true, message: 'Обязательное поле' });
  }

  for (const v of field.validation) {
    switch (v.type) {
      case 'min':
        rules.push({ type: 'number', min: v.value, message: v.message });
        break;
      case 'max':
        rules.push({ type: 'number', max: v.value, message: v.message });
        break;
      case 'regex':
        rules.push({ pattern: new RegExp(v.value), message: v.message });
        break;
      case 'enum':
        rules.push({
          validator: (_, value) =>
            !value || v.value.includes(value)
              ? Promise.resolve()
              : Promise.reject(new Error(v.message || 'Недопустимое значение')),
        });
        break;
      case 'custom':
        // через внешний реестр кастомных валидаторов
        break;
    }
  }

  return rules;
};
```

Таким образом:

- простые проверки выполняются моментально на стороне AntD,
- сложная бизнес‑логика остаётся в MobX (метод `validate()` и `errors`).

---

## 6. UI‑слой: SchemaForm + реестр виджетов

### 6.1. Реестр рендереров

```ts
type FieldRenderer = (props: {
  schema: FieldSchema;
  namePath: (string | number)[];
}) => React.ReactNode;

const defaultRenderers: Record<FieldType, FieldRenderer> = {
  string: () => <Input />,
  text: () => <Input.TextArea autoSize />,
  float: () => <InputNumber style={{ width: '100%' }} />,
  bool: () => <Switch />,
  json: () => null, // json сам по себе не рендерится как инпут
};

const widgetRegistry: Record<string, FieldRenderer> = {
  // Примеры:
  // title: (props) => <Input {...props} maxLength={200} />,
  // price: (props) => <PriceInput {...props} />,
};
```

Принцип:

- `schema.uiWidget` → приоритетный поиск в `widgetRegistry`,
- иначе — рендерер по `schema.type` из `defaultRenderers`.

### 6.2. Рекурсивный рендеринг

Компонент `SchemaForm` обходит `schema` и рендерит поля:

- примитив + `one` — одиночный `Form.Item`,
- примитив + `many` — `Form.List` + Add/Remove,
- `json` + `one` — группа/карточка с вложенными полями,
- `json` + `many` — список таких групп.

Анкета с ошибками из MobX:

```tsx
const SchemaForm = observer(
  <E extends EntitySchema>({
    form,
    model,
    schema,
  }: {
    form: FormInstance;
    model: FormModel<E>;
    schema: E;
  }) => {
    const renderField = (
      key: string,
      field: FieldSchema,
      parentPath: (string | number)[] = []
    ): React.ReactNode => {
      const namePath = [...parentPath, key];
      const pathStr = pathToString(namePath);
      const rules = buildAntdRules(field);

      // 1) json‑поля
      if (field.type === 'json') {
        if (field.cardinality === 'one') {
          return (
            <Card key={pathStr} title={field.label ?? key}>
              {field.children &&
                Object.entries(field.children).map(([childKey, childField]) =>
                  renderField(childKey, childField, namePath)
                )}
            </Card>
          );
        }

        // json + many
        return (
          <Form.List key={pathStr} name={namePath}>
            {(fields, { add, remove }) => (
              <Card
                title={field.label ?? key}
                extra={<Button onClick={() => add()}>Добавить</Button>}
              >
                {fields.map(f => {
                  const itemPath = [...namePath, f.name];
                  const itemPathStr = pathToString(itemPath);

                  return (
                    <Card
                      key={itemPathStr}
                      size="small"
                      style={{ marginBottom: 8 }}
                      extra={<Button onClick={() => remove(f.name)}>Удалить</Button>}
                    >
                      {field.children &&
                        Object.entries(field.children).map(([childKey, childField]) =>
                          renderField(childKey, childField, itemPath)
                        )}
                    </Card>
                  );
                })}
              </Card>
            )}
          </Form.List>
        );
      }

      // 2) Примитивы
      const renderer =
        (field.uiWidget && widgetRegistry[field.uiWidget]) ||
        defaultRenderers[field.type] ||
        (() => <Input />);

      if (field.cardinality === 'one') {
        return (
          <Form.Item
            key={pathStr}
            name={namePath}
            label={field.label ?? key}
            rules={rules}
            validateStatus={model.errorFor(pathStr) ? 'error' : undefined}
            help={model.errorFor(pathStr)}
          >
            {renderer({ schema: field, namePath })}
          </Form.Item>
        );
      }

      // Примитив + many
      return (
        <Form.List key={pathStr} name={namePath}>
          {(fields, { add, remove }) => (
            <Card
              title={field.label ?? key}
              extra={<Button onClick={() => add()}>Добавить</Button>}
            >
              {fields.map(f => {
                const itemPath = [...namePath, f.name];
                const itemPathStr = pathToString(itemPath);
                return (
                  <Space key={itemPathStr} align="baseline">
                    <Form.Item
                      name={itemPath}
                      rules={rules}
                      validateStatus={model.errorFor(itemPathStr) ? 'error' : undefined}
                      help={model.errorFor(itemPathStr)}
                    >
                      {renderer({ schema: field, namePath: itemPath })}
                    </Form.Item>
                    <Button onClick={() => remove(f.name)}>Удалить</Button>
                  </Space>
                );
              })}
            </Card>
          )}
        </Form.List>
      );
    };

    return (
      <Form
        form={form}
        layout="vertical"
        initialValues={model.values}
        onValuesChange={(_, allValues) => model.setAll(allValues)}
      >
        {Object.entries(schema.schema).map(([key, field]) => renderField(key, field))}
      </Form>
    );
  }
);
```

---

## 7. Жизненный цикл формы

1. **Инициализация**
   - есть сырой JSON‑schema (как в примере),
   - дополняем её UI‑мета и правилами валидации (либо сразу на backend).
   - создаём `FormModel` и AntD `Form`:
     ```ts
     const model = new FormModel(productSchema, initialValues);
     const [form] = Form.useForm();
     ```

2. **Рендеринг**  
   Рендерим `<SchemaForm form={form} model={model} schema={productSchema} />`.

3. **Редактирование**
   - пользователь меняет поля,
   - AntD вызывает `onValuesChange` → `model.setAll(allValues)`,
   - MobX оповещает все `observer`‑компоненты.

4. **Валидация и сабмит**
   ```ts
   const handleSubmit = async () => {
     await form.validateFields(); // быстрые правила AntD
     const ok = model.validate(); // бизнес‑валидация, сложные кейсы
     if (!ok) return;
     const payload = model.json;
     // отправка на backend
   };
   ```

---

## 8. Итог: почему это решение гибкое и элегантное

- **Гибкость**
  - Любая новая сущность описывается схемой такого же формата.
  - Можно добавлять новые типы (`date`, `relation`, `file` и т.д.) и виджеты через реестры.

- **Удобство разработки**
  - Типы форм выводятся автоматически, IDE подсказывает структуру.
  - Вся логика валидации и структуры централизована в `EntitySchema` и `FormModel`.

- **Элегантность и расширяемость**
  - MobX — единый источник истины; AntD — тонкий слой представления.
  - Рекурсивный рендер помогает естественно работать с вложенными структурами (`json + many`).
  - Можно постепенно осложнять решение: сначала только required и примитивы, потом массивы, вложенные данные и сложную валидацию.

Этот подход хорошо масштабируется и остаётся читаемым, при этом поддерживая твой изначальный формат схемы и достаточно сложные конструкции вроде `rrrr[].eeee[]`.
