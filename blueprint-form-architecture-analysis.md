# Анализ архитектуры BlueprintForm и план улучшений

## Краткая сводка

### Основные проблемы

1. **Отсутствие централизованного управления состоянием** - нет единой точки управления данными формы
2. **Дублирование логики** - каждый компонент поля самостоятельно обрабатывает `cardinality: 'many'`
3. **Слабая типизация** - `BlueprintFormValues` определён как `Record<string, unknown>`
4. **Низкая расширяемость** - добавление нового типа поля требует изменений в нескольких местах
5. **Проблемы производительности** - отсутствие мемоизации и оптимизации загрузки данных

### Ключевые улучшения

1. **Введение контекста формы** - для условной логики и зависимых полей
2. **Выделение слоя данных** - централизованное управление загрузкой данных
3. **Типизация значений формы** - генерация типов из Path дерева
4. **Регистрация типов полей** - плагинная архитектура для расширяемости
5. **Оптимизация производительности** - мемоизация и кэширование

### Оценка трудозатрат

- **Критичные улучшения**: 3-5 дней
- **Важные улучшения**: 2-3 дня
- **Желательные улучшения**: 3-4 дня
- **Итого**: 8-13 дней разработки

---

## 1. Текущая архитектура

### 1.1. Структура компонентов

```
BlueprintForm (главный компонент)
  └── PathField (роутер по типам)
      ├── PathStringField
      ├── PathTextAreaField
      ├── PathIntField
      ├── PathFloatField
      ├── PathBoolField
      ├── PathDateField
      ├── PathDateTimeField
      ├── PathRefField
      └── PathJsonGroupField (рекурсивный)
          └── PathField (рекурсия)
```

### 1.2. Ключевые компоненты

- **BlueprintForm**: Главный компонент, принимает массив `ZPathTreeNode[]` и рендерит поля
- **PathField**: Роутер, выбирает конкретный компонент поля на основе `data_type`
- **Path\*Field**: Специализированные компоненты для каждого типа данных
- **PathListField**: Универсальный компонент для полей с `cardinality: 'many'`
- **Utils**: Утилиты для генерации меток, правил валидации, имён полей

## 2. Выявленные архитектурные проблемы

### 2.1. Критические проблемы

#### 2.1.1. Отсутствие централизованного управления состоянием формы

**Проблема**: Каждое поле работает независимо через Ant Design Form, но нет единой точки управления данными формы Blueprint.

**Последствия**:

- Сложно отслеживать изменения всех полей
- Нет возможности валидировать связанные поля
- Сложно реализовать условную логику между полями
- Нет единого места для трансформации данных

**Пример**: В `EntryEditorPage` используется `handleValuesChange`, но он только логирует изменения, не обрабатывает их.

#### 2.1.2. Дублирование логики обработки `cardinality: 'many'`

**Проблема**: Каждый компонент поля самостоятельно обрабатывает `cardinality: 'many'` через `PathListField`, но логика не унифицирована.

**Последствия**:

- Код дублируется в каждом компоненте поля
- Сложно изменить поведение списков полей глобально
- Разные поля могут вести себя по-разному для `many`

**Пример**: `PathStringField`, `PathDateField`, `PathTextAreaField` - все имеют одинаковую структуру с `PathListField`.

**Детальный план решения**: См. `cardinality-many-refactoring-plan.md`

#### 2.1.3. Отсутствие типизации значений формы

**Проблема**: `BlueprintFormValues` определён как `Record<string, unknown>`, что не даёт типобезопасности.

**Последствия**:

- Нет автодополнения при работе с данными формы
- Ошибки типов обнаруживаются только в runtime
- Сложно рефакторить структуру данных

**Пример**: В `EntryEditorStore` используется `content_json?: BlueprintFormValues`, но нет гарантий структуры.

#### 2.1.4. Хардкод правил валидации в `getFormItemRules`

**Проблема**: Правила валидации жёстко закодированы в утилите, нет расширяемости.

**Последствия**:

- Сложно добавить новые типы валидации
- Нет возможности переопределить правила для конкретного поля
- Ограниченная поддержка кастомных `validation_rules`

**Пример**: В `getFormItemRules` только `max`, `min`, `pattern` поддерживаются, другие правила игнорируются.

### 2.2. Проблемы проектирования

#### 2.2.1. Нарушение принципа единственной ответственности

**Проблема**: Компоненты полей смешивают логику рендеринга, валидации и обработки данных.

**Последствия**:

- Сложно тестировать компоненты
- Сложно переиспользовать логику
- Нарушение принципа разделения concerns

**Пример**: `PathRefField` содержит логику загрузки данных (`useEffect`, `useState`), что должно быть в отдельном слое.

#### 2.2.2. Отсутствие абстракции для работы с данными

**Проблема**: Нет единого способа загрузки/сохранения данных для полей, которые требуют внешних данных.

**Последствия**:

- Каждое поле реализует загрузку данных самостоятельно
- Нет кэширования запросов
- Сложно мокать данные в тестах

**Пример**: `PathRefField` загружает все entries при каждом рендере, нет оптимизации.

#### 2.2.3. Слабая расширяемость системы

**Проблема**: Добавление нового типа поля требует изменений в нескольких местах.

**Последствия**:

- Нужно изменить `PathField` (switch case)
- Создать новый компонент `Path*Field`
- Обновить `getFormItemRules` если нужны специфичные правила
- Нет плагинной архитектуры

**Пример**: Для добавления типа `email` нужно изменить минимум 3 файла.

#### 2.2.4. Отсутствие контекста формы

**Проблема**: Компоненты полей не имеют доступа к контексту формы (значения других полей, состояние валидации).

**Последствия**:

- Невозможно реализовать условную логику (показать поле только если другое заполнено)
- Невозможно реализовать зависимые поля
- Невозможно реализовать динамическую валидацию

**Пример**: Нет возможности скрыть поле `author.email` если `author.name` не заполнено.

### 2.3. Проблемы производительности

#### 2.3.1. Отсутствие мемоизации вычислений

**Проблема**: Утилиты (`getFieldLabel`, `getFormItemRules`, `getFieldTooltip`) вызываются при каждом рендере без кэширования.

**Последствия**:

- Лишние вычисления при ре-рендерах
- Потенциальные проблемы производительности на больших формах

**Пример**: `getFieldLabel` вызывается в каждом компоненте поля при каждом рендере.

#### 2.3.2. Неоптимальная загрузка данных

**Проблема**: `PathRefField` загружает все entries без пагинации и кэширования.

**Последствия**:

- Медленная загрузка при большом количестве entries
- Лишние запросы при переключении между полями
- Проблемы с памятью

**Пример**: `listEntries({ per_page: 100 })` загружает только 100 записей, но нет пагинации для остальных.

### 2.4. Проблемы тестируемости

#### 2.4.1. Тесная связанность с Ant Design

**Проблема**: Компоненты напрямую зависят от Ant Design компонентов, сложно тестировать без полного рендера формы.

**Последствия**:

- Нужно мокать Ant Design компоненты
- Сложно писать unit-тесты
- Тесты становятся интеграционными вместо unit

**Пример**: Для тестирования `PathStringField` нужно рендерить `Form` из Ant Design.

#### 2.4.2. Отсутствие изоляции бизнес-логики

**Проблема**: Бизнес-логика смешана с логикой представления.

**Последствия**:

- Сложно тестировать логику отдельно от UI
- Невозможно переиспользовать логику в других контекстах

**Пример**: Логика валидации встроена в компоненты, нельзя протестировать отдельно.

## 3. План улучшений

### 3.1. Фаза 1: Рефакторинг архитектуры (Приоритет: Высокий)

#### 3.1.1. Введение контекста формы

**Цель**: Предоставить компонентам полей доступ к контексту формы.

**Действия**:

1. Создать `BlueprintFormContext` с методами:
   - `getFieldValue(path: string): unknown`
   - `setFieldValue(path: string, value: unknown): void`
   - `watchField(path: string, callback: (value: unknown) => void): () => void`
   - `validateField(path: string): Promise<boolean>`
   - `getFormErrors(): Record<string, string[]>`

2. Обернуть `BlueprintForm` в провайдер контекста

3. Использовать контекст в компонентах полей для условной логики

**Ожидаемый результат**: Возможность реализовать зависимые поля и условную логику.

#### 3.1.2. Выделение слоя данных

**Цель**: Разделить логику загрузки данных и рендеринга.

**Действия**:

1. Создать `PathFieldDataProvider` для управления данными полей:
   - Кэширование запросов
   - Пагинация для больших списков
   - Единый интерфейс для загрузки данных

2. Создать хуки для работы с данными:
   - `usePathRefData(path: ZPathTreeNode)` - для ref полей
   - `usePathFieldData(path: ZPathTreeNode)` - универсальный хук

3. Рефакторить `PathRefField` для использования нового слоя

**Ожидаемый результат**: Централизованное управление данными, оптимизация запросов.

#### 3.1.3. Типизация значений формы

**Цель**: Обеспечить типобезопасность при работе с данными формы.

**Действия**:

1. Создать утилиту `generateFormType(paths: ZPathTreeNode[]): Type` для генерации типов из Path дерева

2. Обновить `BlueprintFormValues` для использования сгенерированных типов

3. Обновить `EntryEditorStore` для использования типизированных значений

**Ожидаемый результат**: Автодополнение и проверка типов на этапе компиляции.

### 3.2. Фаза 2: Улучшение расширяемости (Приоритет: Средний)

#### 3.2.1. Регистрация типов полей

**Цель**: Сделать систему расширяемой через регистрацию типов.

**Действия**:

1. Создать `PathFieldRegistry` для регистрации типов полей:

   ```typescript
   interface PathFieldType {
     dataType: ZDataType;
     component: React.ComponentType<PropsPathFieldBase>;
     defaultRules?: (path: ZPathTreeNode) => Rule[];
     dataLoader?: (path: ZPathTreeNode) => Promise<unknown[]>;
   }
   ```

2. Заменить switch case в `PathField` на поиск в реестре

3. Создать утилиту `registerPathFieldType(type: PathFieldType)` для регистрации новых типов

**Ожидаемый результат**: Добавление нового типа поля требует только регистрации, без изменения существующего кода.

#### 3.2.2. Плагинная система валидации

**Цель**: Сделать валидацию расширяемой и настраиваемой.

**Действия**:

1. Создать интерфейс `ValidationRuleHandler`:

   ```typescript
   interface ValidationRuleHandler {
     name: string;
     validate: (value: unknown, ruleValue: string, path: ZPathTreeNode) => Rule | null;
   }
   ```

2. Создать реестр обработчиков правил валидации

3. Обновить `getFormItemRules` для использования реестра

4. Добавить возможность переопределения правил для конкретного поля

**Ожидаемый результат**: Легкое добавление новых типов валидации и переопределение правил.

### 3.3. Фаза 3: Оптимизация производительности (Приоритет: Средний)

#### 3.3.1. Мемоизация вычислений

**Цель**: Оптимизировать вычисления при рендеринге.

**Действия**:

1. Мемоизировать результаты `getFieldLabel`, `getFormItemRules`, `getFieldTooltip` через `useMemo`

2. Создать хук `usePathFieldMeta(path: ZPathTreeNode)` для кэширования метаданных поля

3. Использовать `React.memo` для компонентов полей

**Ожидаемый результат**: Уменьшение количества вычислений при ре-рендерах.

#### 3.3.2. Оптимизация загрузки данных

**Цель**: Оптимизировать загрузку данных для полей, требующих внешних данных.

**Действия**:

1. Реализовать кэширование запросов в `PathFieldDataProvider`

2. Добавить пагинацию для `PathRefField` через виртуализацию или lazy loading

3. Использовать `React.Suspense` для асинхронной загрузки данных

**Ожидаемый результат**: Быстрая загрузка форм даже с большим количеством данных.

### 3.4. Фаза 4: Улучшение тестируемости (Приоритет: Низкий)

#### 3.4.1. Выделение бизнес-логики

**Цель**: Разделить логику и представление для упрощения тестирования.

**Действия**:

1. Вынести логику валидации в отдельные функции

2. Вынести логику трансформации данных в утилиты

3. Создать моки для Ant Design компонентов

**Ожидаемый результат**: Возможность писать unit-тесты для логики отдельно от UI.

#### 3.4.2. Тестовые утилиты

**Цель**: Упростить написание тестов для компонентов формы.

**Действия**:

1. Создать `renderPathField(path: ZPathTreeNode, options?: RenderOptions)` утилиту

2. Создать моки для `BlueprintFormContext`

3. Добавить примеры тестов для каждого типа поля

**Ожидаемый результат**: Быстрое написание тестов для новых типов полей.

## 4. Приоритизация задач

### Критичные (сделать в первую очередь)

1. ✅ Введение контекста формы (3.1.1)
2. ✅ Выделение слоя данных (3.1.2)
3. ✅ Типизация значений формы (3.1.3)

### Важные (сделать во вторую очередь)

4. ✅ Регистрация типов полей (3.2.1)
5. ✅ Плагинная система валидации (3.2.2)
6. ✅ Мемоизация вычислений (3.3.1)

### Желательные (сделать при возможности)

7. ✅ Оптимизация загрузки данных (3.3.2)
8. ✅ Выделение бизнес-логики (3.4.1)
9. ✅ Тестовые утилиты (3.4.2)

## 5. Оценка трудозатрат

- **Фаза 1**: 3-5 дней
- **Фаза 2**: 2-3 дня
- **Фаза 3**: 2-3 дня
- **Фаза 4**: 1-2 дня

**Итого**: 8-13 дней разработки

## 6. Риски и митигация

### Риск 1: Breaking changes для существующего кода

**Митигация**: Сохранить обратную совместимость через адаптеры, постепенный рефакторинг.

### Риск 2: Усложнение архитектуры

**Митигация**: Следовать принципу YAGNI, добавлять абстракции только при необходимости.

### Риск 3: Проблемы с производительностью при введении контекста

**Митигация**: Использовать селекторы и мемоизацию, профилировать изменения.

## 7. Метрики успеха

1. **Расширяемость**: Добавление нового типа поля занимает < 30 минут
2. **Производительность**: Рендеринг формы с 50 полями < 100ms
3. **Типобезопасность**: 100% покрытие типов для значений формы
4. **Тестируемость**: Покрытие тестами > 80% для бизнес-логики
