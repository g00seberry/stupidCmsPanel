---
alwaysApply: true
---

# Правила проекта (TypeScript/React)

## 0) Коротко — самое важное

- Не используем `function` и `var` — только `const` и стрелочные функции.
- Перед каждым **классом**, **функцией**, **типом** и **React-компонентом** обязателен JSDoc-комментарий.
- Имена файлов — `camelCase`. Если файл описывает **одну сущность**, имя файла **совпадает** с названием сущности (может быть `PascalCase`): `ZLoginField.ts`.
- Имена интерфейсов пропсов React-компонентов начинаются с `Props{ComponentName}`.
- Для Zod: схемы — `zSomething`, типы, выведенные из схем — `ZSomething`.

---

## 1) Именование и структура файлов

- **По умолчанию**: `camelCase.ts` / `camelCase.tsx`.
- **Одна сущность в файле** → имя файла = имя сущности (с сохранением регистра):  
  пример:
  ```ts
  // ZLoginField.ts
  export const zLoginField = z.enum(['email', 'password']);
  export type ZLoginField = z.infer<typeof zLoginField>;
  ```
- Расширения:
  - `.ts` — для чистого TS,
  - `.tsx` — для файлов с JSX.
- Индекс-файлы:
  - `index.ts` допускается только для реэкспорта публичного API из папки (без логики).
- Тесты и истории:
  - Тесты: `*.test.ts` / `*.test.tsx`
  - Storybook: `*.stories.tsx`

---

## 2) Именование сущностей

- **Типы/интерфейсы/классы/компоненты** — `PascalCase`: `User`, `LoginForm`, `ZLoginField`.
- **Функции/переменные** — `camelCase`: `buildUser`, `loginUser`.
- **React-компоненты** — `PascalCase`: `LoginForm`.
- **Пропсы компонентов** — `Props{ComponentName}`: `PropsLoginForm`.
- **Zod**:
  - схема: `zLoginField`
  - выведенный тип: `ZLoginField` (через `z.infer`)

---

## 3) Экспорты

- Отдаём предпочтение **именованным экспортам** (без `default`), чтобы упростить рефакторинг и поиск.
- Один файл — одна главная сущность (если есть необходимость — дополнительные утилиты только как `internal`/неэкспортируемые).

---

## 4) Стиль кода

- **Стрелочные функции**:

  ```ts
  // ✅ правильно
  export const buildUser = (id: string): User => ({ id });

  // ❌ неправильно
  export function buildUser(id: string): User {
    /* ... */
  }
  ```

- **Переменные**: только `const` (и `let`, если нужна переинициализация); **никогда** `var`.
- **Иммутабельность**: избегаем мутаций, используем неизменяемые операции и `readonly` там, где уместно.
- **Асинхронщина**: `async/await` вместо `.then()/.catch()`, с явной обработкой ошибок.
- **Импорты**: сначала внешние пакеты, потом алиасы, потом относительные; без «глубоких» импортов из чужих пакетов.
- **Форматирование**: единый стиль (ESLint + Prettier); следуем автофиксам линтера.

---

## 5) Комментарии и документация (обязательно)

- Используем **JSDoc**: краткое описание, при необходимости `@param`, `@returns`, `@throws`.

Пример для функции:

```ts
/**
 * Собирает пользователя из исходных данных.
 * @param id Идентификатор пользователя.
 * @returns Объект пользователя.
 */
export const buildUser = (id: string): User => ({ id });
```

Пример для компонента:

```tsx
/**
 * Поле ввода e-mail с валидацией.
 */
export const EmailInput: React.FC<PropsEmailInput> = ({ value, onChange }) => {
  return <input type="email" value={value} onChange={onChange} />;
};

export interface PropsEmailInput {
  /** Текущее значение поля */
  value: string;
  /** Обработчик изменения значения */
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}
```

---

## 6) React-компоненты

- Функциональные компоненты на стрелочных функциях.
- Пропсы — отдельный интерфейс `Props{ComponentName}` (см. выше).
- Старайтесь делать компоненты **чистыми** и **детерминированными**; сайд-эффекты — в хуках.
- Хуки называем с префиксом `use` и храним в `hooks/` (файлы — `camelCase`, один хук — один файл).

---

## 7) Валидация и типы (Zod)

- Любые входные данные «снаружи» (API, формы, localStorage) валидируем Zod-схемами.
- Схема: `zSomething`, выведенный тип: `ZSomething`:
  ```ts
  export const zLoginField = z.enum(['email', 'password']);
  export type ZLoginField = z.infer<typeof zLoginField>;
  ```
- Схемы и типы держим рядом с доменной логикой или в `schemas/` по вертикали.

---

## 8) Ошибки и логирование

- Не бросаем «сырые» строки. Создаём типизированные ошибки или используем `Error` с осмысленным сообщением.
- Для ожидаемых кейсов — `Either`-подобный результат или чёткая сигнатура возврата.

---

## 9) Организация модулей

- «Фичи» и «домены» отделяем папками. Внутри — `components/`, `hooks/`, `schemas/`, `services/`, `utils/`.
- Публичное API папки — через `index.ts` (только реэкспорт нужного).

---

## 10) Примеры «как надо / как не надо»

**Файл одной сущности**  
`ZLoginField.ts` ✅ (имя = сущность)  
`zLoginField.ts` ❌ (теряется связь с типом/сущностью)

**Стрелочные функции и const**

```ts
// ✅
export const fetchUser = async (id: string): Promise<User> => {
  // ...
};

// ❌
export async function fetchUser(id: string): Promise<User> {
  /* ... */
}

var counter = 0; // ❌
```

**Компонент с корректными пропсами**

```tsx
export interface PropsLoginForm {
  email: string;
  password: string;
  onSubmit: (data: { email: string; password: string }) => void;
}

/** Форма логина с локальной валидацией */
export const LoginForm: React.FC<PropsLoginForm> = ({ email, password, onSubmit }) => {
  // ...
  return <form /* ... */ />;
};
```

---

## 11) Проверка в PR

- PR не принимается, если:
  - есть `function`/`var`;
  - отсутствуют требуемые JSDoc-комментарии;
  - нарушены правила имени файлов/сущностей/пропсов;
  - нет валидации входных данных там, где она ожидается.
