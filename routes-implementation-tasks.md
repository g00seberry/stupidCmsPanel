# Задачи по реализации раздела управления маршрутами

## Этап 1: Типы и схемы валидации (Zod)

### Задача 1: Создать типы и Zod-схемы для RouteNode

**Файл**: `src/types/routes.ts`

**Описание**:

- Создать Zod-схемы для всех типов данных маршрутов согласно API документации
- Реализовать схемы: `zRouteNode`, `zRouteNodeKind`, `zRouteNodeActionType`, `zHttpMethod`
- Создать схемы для вложенных объектов: `entry`, `parent`, `children`
- Реализовать схемы ответов API: `zRouteNodeResponse`, `zRouteNodeListResponse`
- Вывести TypeScript типы из схем

**Критерии приёмки**:

- Все схемы соответствуют API документации
- Типы корректно выводятся через `z.infer`
- Поддержка рекурсивной структуры `children` через `z.lazy()`
- Обработка nullable полей

---

### Задача 2: Создать DTO схемы для создания и обновления маршрутов

**Файл**: `src/types/routes.ts` (дополнение)

**Описание**:

- Реализовать `zCreateRouteNodeDto` с валидацией обязательных полей
- Реализовать `zUpdateRouteNodeDto` как `Partial<zCreateRouteNodeDto>`
- Реализовать `zReorderRouteNodesRequest` для переупорядочивания
- Добавить условную валидацию (например, `entry_id` обязателен для `action_type=entry`)
- Добавить валидацию формата `action` для разных типов

**Критерии приёмки**:

- Валидация соответствует правилам из API документации
- Условная валидация работает корректно
- Все поля имеют правильные ограничения (min, max, regex)

---

### Задача 3: Создать схему для списка маршрутов с полем `source`

**Файл**: `src/types/routes.ts` (дополнение)

**Описание**:

- Реализовать `zRouteNodeListItem` как упрощённую версию `zRouteNode` с полем `source`
- Поле `source` может быть `"database"` или имя файла (например, `"web_core.php"`)
- Создать `zRouteNodeListResponse` для ответа GET `/api/v1/admin/routes`
- Исключить из списка вложенные объекты `entry`, `parent`, `children`

**Критерии приёмки**:

- Схема корректно валидирует плоский список маршрутов
- Поле `source` присутствует и валидируется
- Типы соответствуют ответу API

---

## Этап 2: API функции

### Задача 4: Реализовать базовые CRUD операции для маршрутов

**Файл**: `src/api/apiRoutes.ts`

**Описание**:

- Создать функции: `listRoutes()`, `getRoute(id)`, `createRoute(payload)`, `updateRoute(id, payload)`, `deleteRoute(id)`
- Использовать паттерн `getAdminRoutesUrl(path)` для формирования URL
- Валидировать все ответы через Zod схемы
- Добавить JSDoc комментарии с примерами использования

**Критерии приёмки**:

- Все функции следуют паттерну существующих API модулей
- Ответы валидируются через Zod
- Обработка ошибок через существующий механизм

---

### Задача 5: Реализовать функцию переупорядочивания маршрутов

**Файл**: `src/api/apiRoutes.ts` (дополнение)

**Описание**:

- Создать функцию `reorderRoutes(nodes)` для POST `/api/v1/admin/routes/reorder`
- Принимать массив узлов с `id`, `parent_id`, `sort_order`
- Валидировать запрос и ответ через Zod схемы
- Добавить обработку ошибок валидации

**Критерии приёмки**:

- Функция корректно отправляет данные в нужном формате
- Валидация входных данных работает
- Обработка ошибок транзакции (500) реализована

---

## Этап 3: Store для управления состоянием

### Задача 6: Создать RoutesListStore для списка маршрутов

**Файл**: `src/pages/RoutesPage/RoutesListStore.ts`

**Описание**:

- Реализовать MobX Store с использованием `makeAutoObservable`
- Использовать `PaginatedDataLoader` для загрузки списка маршрутов
- Добавить фильтры: по `source` (database/declarative), по `enabled`, по `kind`
- Реализовать методы: `loadRoutes()`, `setFilters()`, `resetFilters()`
- Добавить флаги состояния: `pending`, `initialLoading`

**Критерии приёмки**:

- Store следует паттерну `EntriesListStore`
- Фильтрация работает корректно
- Состояние управляется через сеттеры

---

### Задача 7: Создать RouteEditorStore для редактирования маршрута

**Файл**: `src/pages/RouteEditorPage/RouteEditorStore.ts`

**Описание**:

- Реализовать Store для создания/редактирования одного маршрута
- Методы: `loadRoute(id)`, `createRoute(payload)`, `updateRoute(id, payload)`, `deleteRoute(id)`
- Управление состоянием формы: `route`, `pending`, `saving`, `errors`
- Валидация данных перед отправкой
- Обработка ошибок валидации с сохранением в `errors`

**Критерии приёмки**:

- Store следует паттерну `EntryEditorStore`
- Валидация работает на клиенте и сервере
- Ошибки корректно отображаются в форме

---

## Этап 4: UI компоненты

### Задача 8: Создать компонент RoutesTable для отображения списка

**Файл**: `src/components/RoutesTable/RoutesTable.tsx`

**Описание**:

- Использовать `PaginatedTable` как основу
- Колонки: `uri`, `methods`, `name`, `action_type`, `enabled`, `source`, `readonly`
- Визуальное различие декларативных (отрицательные ID) и динамических маршрутов
- Иконки/теги для `kind` (group/route), `action_type` (controller/entry)
- Действия: редактирование, удаление (только для не-readonly), переключение `enabled`

**Критерии приёмки**:

- Таблица использует существующие компоненты AntD
- Визуальное различие readonly маршрутов
- Действия работают корректно

---

### Задача 9: Создать компонент RouteForm для создания/редактирования

**Файл**: `src/components/RouteForm/RouteForm.tsx`

**Описание**:

- Форма на основе Ant Design Form
- Поля: `kind`, `name`, `uri`, `methods`, `action_type`, `action`, `entry_id`, `enabled`, `middleware`
- Условная логика: показывать `uri`/`methods` только для `kind=route`
- Условная логика: показывать `entry_id` только для `action_type=entry`
- Валидация полей согласно API документации
- Селектор Entry для выбора `entry_id`

**Критерии приёмки**:

- Форма следует паттерну существующих форм
- Условная логика работает корректно
- Валидация соответствует API требованиям

---

### Задача 10: Создать компонент RouteGroupForm для групп маршрутов

**Файл**: `src/components/RouteGroupForm/RouteGroupForm.tsx`

**Описание**:

- Форма для создания/редактирования группы маршрутов (`kind=group`)
- Поля: `name`, `prefix`, `domain`, `namespace`, `middleware`, `enabled`
- Валидация префикса на зарезервированные значения
- Визуальное отображение иерархии (если есть `parent_id`)

**Критерии приёмки**:

- Форма корректно обрабатывает группы
- Валидация префиксов работает
- Иерархия отображается понятно

---

### Задача 11: Создать компонент RoutesTree для иерархического отображения

**Файл**: `src/components/RoutesTree/RoutesTree.tsx`

**Описание**:

- Использовать `Tree` компонент из Ant Design
- Отображение иерархии маршрутов через `parent_id`
- Визуальное различие групп и маршрутов
- Drag & Drop для переупорядочивания (опционально, через `@dnd-kit`)
- Контекстное меню для действий

**Критерии приёмки**:

- Дерево корректно отображает иерархию
- Визуальное различие типов узлов
- Действия доступны через контекстное меню

---

### Задача 12: Создать компонент RouteFilters для фильтрации списка

**Файл**: `src/components/RouteFilters/RouteFilters.tsx`

**Описание**:

- Использовать `FilterForm` как основу
- Фильтры: `source` (all/database/declarative), `enabled` (all/true/false), `kind` (all/group/route)
- Интеграция с `RoutesListStore`
- Сброс фильтров к значениям по умолчанию

**Критерии приёмки**:

- Фильтры работают с Store
- UI следует паттерну существующих фильтров
- Сброс работает корректно

---

## Этап 5: Страницы

### Задача 13: Создать страницу RoutesPage со списком маршрутов

**Файл**: `src/pages/RoutesPage/RoutesPage.tsx`

**Описание**:

- Использовать `PageHeader` для заголовка
- Интегрировать `RoutesTable` и `RouteFilters`
- Использовать `RoutesListStore` для управления состоянием
- Кнопка "Создать маршрут" ведёт на страницу создания
- Инициализация Store при монтировании компонента

**Критерии приёмки**:

- Страница следует паттерну `EntriesListPage`
- Все компоненты интегрированы
- Навигация работает корректно

---

### Задача 14: Создать страницу RouteEditorPage для создания/редактирования

**Файл**: `src/pages/RouteEditorPage/RouteEditorPage.tsx`

**Описание**:

- Использовать `RouteEditorStore` для управления состоянием
- Интегрировать `RouteForm` или `RouteGroupForm` в зависимости от типа
- Обработка режимов: создание (`/routes/new`) и редактирование (`/routes/:id`)
- Кнопки: "Сохранить", "Отмена" (возврат к списку)
- Отображение ошибок валидации

**Критерии приёмки**:

- Страница следует паттерну `EntryEditorPage`
- Оба режима работают корректно
- Навигация и сохранение работают

---

### Задача 15: Добавить роуты в систему навигации

**Файл**: `src/routes.tsx`

**Описание**:

- Добавить роуты: `/routes` (список), `/routes/new` (создание), `/routes/:id` (редактирование)
- Интегрировать с существующей системой роутинга
- Добавить пункт меню в `MainSidebar` для доступа к маршрутам

**Критерии приёмки**:

- Роуты работают корректно
- Навигация доступна из меню
- Защита роутов через `AuthStore` работает

---

## Этап 6: Расширенная функциональность

### Задача 16: Реализовать переупорядочивание через Drag & Drop

**Файл**: `src/components/RoutesTree/RoutesTree.tsx` (дополнение)

**Описание**:

- Использовать `@dnd-kit` для Drag & Drop
- Визуальная обратная связь при перетаскивании
- Вызов `reorderRoutes()` после завершения перетаскивания
- Валидация допустимых перемещений (например, нельзя переместить в readonly группу)

**Критерии приёмки**:

- Drag & Drop работает плавно
- Валидация перемещений работает
- Изменения сохраняются на сервере

---

### Задача 17: Реализовать предпросмотр маршрута с информацией

**Файл**: `src/components/RoutePreview/RoutePreview.tsx`

**Описание**:

- Компонент для отображения полной информации о маршруте
- Показывать: полный URI (с учётом префиксов), методы, действие, middleware, связанную Entry
- Визуализация иерархии (родители)
- Отображение статуса (enabled/disabled, readonly)

**Критерии приёмки**:

- Вся информация отображается корректно
- Иерархия визуализирована понятно
- Компонент переиспользуемый

---

### Задача 18: Реализовать валидацию конфликтов URI на клиенте

**Файл**: `src/components/RouteForm/RouteForm.tsx` (дополнение)

**Описание**:

- Проверка уникальности URI + methods перед отправкой
- Использовать список маршрутов из Store для проверки
- Показывать предупреждение при потенциальном конфликте
- Валидация зарезервированных префиксов

**Критерии приёмки**:

- Валидация работает до отправки формы
- Сообщения об ошибках понятны
- Производительность проверки приемлема

---

### Задача 19: Реализовать массовые операции

**Файл**: `src/components/RoutesTable/RoutesTable.tsx` (дополнение)

**Описание**:

- Выбор нескольких маршрутов через чекбоксы
- Массовые действия: включить/выключить, удалить
- Подтверждение массового удаления
- Обработка ошибок при массовых операциях

**Критерии приёмки**:

- Выбор работает корректно
- Массовые операции выполняются
- Ошибки обрабатываются

---

### Задача 20: Добавить экспорт/импорт маршрутов (опционально)

**Файл**: `src/components/RoutesExport/RoutesExport.tsx`

**Описание**:

- Кнопка экспорта списка маршрутов в JSON
- Формат экспорта соответствует структуре API
- Импорт маршрутов из JSON файла
- Валидация импортируемых данных
- Предпросмотр перед импортом

**Критерии приёмки**:

- Экспорт/импорт работают корректно
- Валидация данных работает
- Пользовательский опыт удобный

---

## Приоритеты выполнения

**Высокий приоритет** (MVP):

- Задачи 1-7, 9, 13-15

**Средний приоритет** (базовая функциональность):

- Задачи 8, 10-12, 16-18

**Низкий приоритет** (улучшения UX):

- Задачи 19-20

---

## Зависимости между задачами

```
Задачи 1-3 (типы) → Задачи 4-5 (API) → Задачи 6-7 (Store) → Задачи 8-12 (компоненты) → Задачи 13-15 (страницы)
                                                                                              ↓
                                                                                    Задачи 16-20 (расширения)
```

---

## Примечания

- Все задачи должны следовать кодстайлу проекта (см. `codestyle.mdc`)
- Использовать существующие паттерны и утилиты
- Добавлять JSDoc комментарии для всех публичных сущностей
- Тестировать интеграцию с существующими компонентами
- Обрабатывать ошибки через `onError` утилиту
