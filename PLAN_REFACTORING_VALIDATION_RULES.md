# План рефакторинга ValidationRulesFormV2

## Цель
Упростить решение, убрать избыточные абстракции, вынести общую логику, улучшить структуру без потери гибкости и читаемости.

## Принципы рефакторинга

1. **DRY** - убрать дублирование через вынос общей логики
2. **KISS** - упростить, но не переусердствовать
3. **Separation of Concerns** - сохранить разделение типов, логики и компонентов
4. **Группировка вместо объединения** - группировать похожие компоненты, но не объединять все в один файл
5. **Вынос общей логики** - создавать переиспользуемые хуки/утилиты вместо универсальных компонентов

## Анализ текущих проблем

1. **Дублирование логики simple/extended** - ConditionalRuleRenderer, UniqueRuleRenderer, ExistsRuleRenderer имеют одинаковую логику переключения режимов
2. **Похожие простые рендереры** - RequiredRuleRenderer и ArrayUniqueRuleRenderer идентичны, MinMaxRuleRenderer и ArrayItemsRuleRenderer похожи
3. **Избыточная вложенность в регистре** - `renderer.component` можно упростить
4. **Сложная логика handleAddRules** - можно упростить через маппинг значений по умолчанию
5. **Дублирование в utils.ts** - hasRule дублирует логику getActiveRules
6. **Неоптимальная структура папок** - все рендереры в одной папке без группировки

## План рефакторинга (15 шагов)

### Фаза 1: Вынос общей логики (шаги 1-4)

**Шаг 1: Создать хук useSimpleExtendedMode**
- Создать `hooks/useSimpleExtendedMode.ts`
- Вынести логику переключения между простым и расширенным форматом
- Использовать в ConditionalRuleRenderer, UniqueRuleRenderer, ExistsRuleRenderer
- **Результат**: убрать дублирование ~50 строк кода в каждом рендерере

**Шаг 2: Создать общий компонент для boolean правил**
- Создать `renderers/shared/BooleanRuleRenderer.tsx`
- Использовать для RequiredRuleRenderer и ArrayUniqueRuleRenderer
- **Результат**: убрать дублирование, но сохранить возможность кастомизации

**Шаг 3: Упростить структуру регистра**
- Убрать вложенность `renderer.component` → сделать `renderer` напрямую компонентом
- Перенести `dependencies` в `meta` как опциональные поля
- Упростить типы: убрать `RuleRendererConfig`, оставить `RuleDependencies` в `meta`
- **Результат**: более плоская и понятная структура

**Шаг 4: Создать маппинг значений по умолчанию**
- Создать `constants/defaultRuleValues.ts` с маппингом `RuleKey → default value`
- Упростить `handleAddRules` через маппинг
- **Результат**: убрать сложную логику с множеством if-else

### Фаза 2: Группировка и упрощение рендереров (шаги 5-8)

**Шаг 5: Реорганизовать структуру папок рендереров**
- Создать `renderers/basic/` - простые правила (Required, MinMax, Pattern)
- Создать `renderers/array/` - правила для массивов (ArrayItems, ArrayUnique)
- Создать `renderers/conditional/` - условные правила (Conditional)
- Создать `renderers/complex/` - сложные правила (Unique, Exists, FieldComparison)
- Создать `renderers/shared/` - общие компоненты (BooleanRuleRenderer)
- **Результат**: логическая группировка, но сохранение отдельных файлов

**Шаг 6: Обновить рендереры для использования хука**
- Обновить ConditionalRuleRenderer, UniqueRuleRenderer, ExistsRuleRenderer
- Использовать `useSimpleExtendedMode` вместо дублированной логики
- **Результат**: уменьшение кода на ~40 строк в каждом

**Шаг 7: Обновить простые рендереры**
- RequiredRuleRenderer и ArrayUniqueRuleRenderer использовать BooleanRuleRenderer
- Или оставить как есть, если нужна кастомизация (например, разные tooltips)
- **Результат**: упрощение или сохранение гибкости

**Шаг 8: Обновить импорты в регистре**
- Обновить все импорты под новую структуру папок
- **Результат**: актуальные импорты

### Фаза 3: Упрощение утилит и логики (шаги 9-12)

**Шаг 9: Упростить utils.ts**
- Убрать `hasRule` - использовать `getActiveRules(validationRules).includes(ruleKey)`
- Упростить `getRuleValue` - можно инлайнить, если используется только в одном месте
- Проверить использование `getActiveRules` - оставить, если используется в 2+ местах
- **Результат**: убрать дублирование, но сохранить переиспользуемые функции

**Шаг 10: Упростить ValidationRulesFormV2**
- Использовать маппинг значений по умолчанию в `handleAddRules`
- Упростить `handleRemoveRule` - использовать утилиту из `validationRules.ts` если есть
- Объединить `handleEditSave` и `handleEditRemove` только если логика действительно одинаковая
- **Результат**: более простая и понятная логика

**Шаг 11: Оптимизировать useMemo в RuleSelectorModal**
- Проанализировать каждый `useMemo`:
  - `rulesByCategory` - оставить (сложное вычисление)
  - `availableRules` - оставить (зависит от `rulesByCategory` и `selectedRules`)
- Убрать только те, которые действительно не нужны
- **Результат**: сохранить производительность, убрать лишнее

**Шаг 12: Упростить модальные окна**
- Упростить внутреннюю логику RuleSelectorModal и RuleEditModal
- Убрать лишние обертки, но сохранить разделение файлов
- **Результат**: более простой код, но сохранение разделения concerns

### Фаза 4: Финальная оптимизация (шаги 13-15)

**Шаг 13: Проверить и упростить типы**
- Проверить `RuleRendererProps` - убрать неиспользуемые поля (`value`, `onChange` если не используются)
- Упростить `RuleMeta` - добавить опциональные `dataTypes` и `cardinality` вместо отдельного `RuleDependencies`
- **Результат**: более простые типы, но сохранение типобезопасности

**Шаг 14: Оптимизировать импорты**
- Убрать неиспользуемые импорты
- Проверить реэкспорты - убрать лишние
- **Результат**: чистые импорты

**Шаг 15: Финальная проверка и очистка**
- Удалить неиспользуемый код
- Проверить все файлы на дублирование
- Обновить документацию
- Проверить линтер
- **Результат**: чистый, поддерживаемый код

## Ожидаемый результат

### Структура после рефакторинга:

```
ValidationRulesFormV2/
├── index.ts
├── types.ts                    # Типы (отдельно)
├── registry.ts                  # Регистр (отдельно)
├── utils.ts                     # Утилиты (упрощенные)
├── constants/
│   └── defaultRuleValues.ts     # Маппинг значений по умолчанию
├── hooks/
│   └── useSimpleExtendedMode.ts # Хук для simple/extended режима
├── renderers/
│   ├── basic/
│   │   ├── RequiredRuleRenderer.tsx
│   │   ├── MinMaxRuleRenderer.tsx
│   │   └── PatternRuleRenderer.tsx
│   ├── array/
│   │   ├── ArrayItemsRuleRenderer.tsx
│   │   └── ArrayUniqueRuleRenderer.tsx
│   ├── conditional/
│   │   └── ConditionalRuleRenderer.tsx
│   ├── complex/
│   │   ├── UniqueRuleRenderer.tsx
│   │   ├── ExistsRuleRenderer.tsx
│   │   └── FieldComparisonRuleRenderer.tsx
│   └── shared/
│       └── BooleanRuleRenderer.tsx
├── RuleTag.tsx                  # Отдельно (переиспользуемый)
├── RuleTagsList.tsx             # Отдельно
├── RuleSelectorModal.tsx        # Отдельно
├── RuleEditModal.tsx            # Отдельно
└── ValidationRulesFormV2.tsx
```

### Метрики:

**До рефакторинга:**
- ~18 файлов
- ~1500 строк кода
- Дублирование логики simple/extended в 3 рендерерах
- Сложная логика handleAddRules

**После рефакторинга:**
- ~20 файлов (но с логической группировкой)
- ~1200-1300 строк кода (уменьшение за счет выноса общей логики)
- Общая логика в хуке и общих компонентах
- Простая логика через маппинг
- Лучшая структура и читаемость

## Риски и меры предосторожности

1. **Не сломать функциональность** - тестировать после каждого шага
2. **Сохранить типизацию** - не терять типы при упрощении
3. **Сохранить производительность** - не удалять useMemo без анализа
4. **Сохранить гибкость** - не создавать слишком универсальные компоненты
5. **Проверять линтер** - после каждого шага проверять ошибки

## Преимущества нового подхода

1. ✅ **Сохранение читаемости** - файлы остаются небольшими и понятными
2. ✅ **Логическая группировка** - похожие компоненты в одной папке
3. ✅ **Вынос общей логики** - переиспользуемые хуки и компоненты
4. ✅ **Сохранение гибкости** - каждый рендерер может быть кастомизирован
5. ✅ **Улучшение поддерживаемости** - проще найти и изменить нужный компонент
6. ✅ **Сохранение производительности** - useMemo анализируется индивидуально
7. ✅ **Разделение concerns** - типы, логика и компоненты разделены

## Что НЕ делаем (избегаем недостатков старого плана)

1. ❌ НЕ объединяем все рендереры в один файл
2. ❌ НЕ создаем универсальный SimpleExtendedRuleRenderer с пропсами
3. ❌ НЕ инлайним утилиты, используемые в нескольких местах
4. ❌ НЕ объединяем types.ts и registry.ts
5. ❌ НЕ объединяем модальные окна
6. ❌ НЕ удаляем все useMemo без анализа
7. ❌ НЕ объединяем RuleTag и RuleTagsList без необходимости

